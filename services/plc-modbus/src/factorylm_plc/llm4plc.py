"""
LLM4PLC Integration Module.

Provides Structured Text (IEC 61131-3) code generation utilities
for integration with Claude/LLM-based PLC programming.

This module enables:
1. ST code generation from natural language requirements
2. Syntax validation for generated code
3. Template-based code scaffolding
4. Integration with CCW deployment workflow
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional
from enum import Enum
import re


class STDataType(Enum):
    """IEC 61131-3 Standard Data Types."""
    BOOL = "BOOL"
    INT = "INT"
    DINT = "DINT"
    REAL = "REAL"
    TIME = "TIME"
    STRING = "STRING"


@dataclass
class STVariable:
    """Structured Text variable declaration."""
    name: str
    data_type: STDataType
    initial_value: Optional[str] = None
    comment: Optional[str] = None

    def to_st(self) -> str:
        """Convert to ST declaration string."""
        decl = f"    {self.name} : {self.data_type.value}"
        if self.initial_value:
            decl += f" := {self.initial_value}"
        if self.comment:
            decl += f"; (* {self.comment} *)"
        else:
            decl += ";"
        return decl


@dataclass
class STProgram:
    """
    Represents an IEC 61131-3 Structured Text program.

    Provides generation, validation, and serialization of ST code
    suitable for Allen-Bradley Micro 820 PLCs.
    """
    name: str
    variables: List[STVariable] = field(default_factory=list)
    body: str = ""
    author: str = "Claude LLM4PLC"
    created: datetime = field(default_factory=datetime.now)

    # Micro 820 global variables available from PLC
    GLOBAL_VARIABLES = {
        # Holding Registers (INT)
        "motor_speed": STDataType.INT,
        "motor_current": STDataType.INT,
        "temperature": STDataType.INT,
        "pressure": STDataType.INT,
        "conveyor_speed": STDataType.INT,
        "error_code": STDataType.INT,
        # Coils (BOOL)
        "motor_running": STDataType.BOOL,
        "motor_stopped": STDataType.BOOL,
        "fault_alarm": STDataType.BOOL,
        "conveyor_running": STDataType.BOOL,
        "sensor_1_active": STDataType.BOOL,
        "sensor_2_active": STDataType.BOOL,
        "e_stop_active": STDataType.BOOL,
    }

    def add_variable(
        self,
        name: str,
        data_type: STDataType,
        initial_value: Optional[str] = None,
        comment: Optional[str] = None,
    ) -> None:
        """Add a local variable to the program."""
        self.variables.append(STVariable(name, data_type, initial_value, comment))

    def set_body(self, code: str) -> None:
        """Set the main program logic."""
        self.body = code

    def to_st(self) -> str:
        """
        Generate complete ST program code.

        Returns:
            str: Complete IEC 61131-3 Structured Text program.
        """
        lines = []

        # Header comment
        lines.append(f"(* Program: {self.name} *)")
        lines.append(f"(* Generated by: {self.author} *)")
        lines.append(f"(* Date: {self.created.strftime('%Y-%m-%d %H:%M:%S')} *)")
        lines.append("")

        # Program declaration
        lines.append(f"PROGRAM {self.name}")

        # Variable declarations
        if self.variables:
            lines.append("VAR")
            for var in self.variables:
                lines.append(var.to_st())
            lines.append("END_VAR")

        lines.append("")

        # Program body
        if self.body:
            for line in self.body.strip().split("\n"):
                lines.append(line)

        lines.append("")
        lines.append(f"END_PROGRAM")

        return "\n".join(lines)

    def validate_syntax(self) -> List[str]:
        """
        Validate ST code syntax.

        Returns:
            List[str]: List of syntax errors found (empty if valid).
        """
        errors = []
        code = self.to_st()

        # Remove comments before checking keywords to avoid false positives
        # ST comments are (* ... *)
        code_no_comments = re.sub(r'\(\*.*?\*\)', '', code, flags=re.DOTALL)

        # Check for balanced IF/END_IF
        if_count = len(re.findall(r'\bIF\b', code_no_comments, re.IGNORECASE))
        endif_count = len(re.findall(r'\bEND_IF\b', code_no_comments, re.IGNORECASE))
        if if_count != endif_count:
            errors.append(f"Unbalanced IF/END_IF: {if_count} IF vs {endif_count} END_IF")

        # Check for balanced CASE/END_CASE
        case_count = len(re.findall(r'\bCASE\b', code_no_comments, re.IGNORECASE))
        endcase_count = len(re.findall(r'\bEND_CASE\b', code_no_comments, re.IGNORECASE))
        if case_count != endcase_count:
            errors.append(f"Unbalanced CASE/END_CASE: {case_count} CASE vs {endcase_count} END_CASE")

        # Check for balanced FOR/END_FOR
        for_count = len(re.findall(r'\bFOR\b', code_no_comments, re.IGNORECASE))
        endfor_count = len(re.findall(r'\bEND_FOR\b', code_no_comments, re.IGNORECASE))
        if for_count != endfor_count:
            errors.append(f"Unbalanced FOR/END_FOR: {for_count} FOR vs {endfor_count} END_FOR")

        # Check for balanced WHILE/END_WHILE
        while_count = len(re.findall(r'\bWHILE\b', code_no_comments, re.IGNORECASE))
        endwhile_count = len(re.findall(r'\bEND_WHILE\b', code_no_comments, re.IGNORECASE))
        if while_count != endwhile_count:
            errors.append(f"Unbalanced WHILE/END_WHILE: {while_count} WHILE vs {endwhile_count} END_WHILE")

        # Check PROGRAM/END_PROGRAM (these should always exist, even outside comments)
        if not re.search(r'\bPROGRAM\b', code_no_comments, re.IGNORECASE):
            errors.append("Missing PROGRAM declaration")
        if not re.search(r'\bEND_PROGRAM\b', code_no_comments, re.IGNORECASE):
            errors.append("Missing END_PROGRAM")

        # Check for common errors
        if re.search(r':=\s*=', code_no_comments):
            errors.append("Invalid assignment operator (found ':= =' instead of ':=')")

        return errors


def generate_conveyor_control() -> STProgram:
    """
    Generate a basic conveyor control program.

    Example program that starts the conveyor when sensor 1 detects
    a part, and stops it when sensor 2 detects the part.

    Returns:
        STProgram: Ready-to-deploy conveyor control program.
    """
    program = STProgram(name="ConveyorControl")

    # Add local variables for edge detection
    program.add_variable("prev_sensor_1", STDataType.BOOL, "FALSE", "Previous sensor 1 state")
    program.add_variable("prev_sensor_2", STDataType.BOOL, "FALSE", "Previous sensor 2 state")

    # Set the control logic
    program.set_body("""
(* Safety check: Stop everything if E-Stop is active *)
IF e_stop_active THEN
    conveyor_running := FALSE;
    motor_running := FALSE;
    conveyor_speed := 0;
    motor_speed := 0;
    RETURN;
END_IF;

(* Start conveyor when part detected at sensor 1 *)
IF sensor_1_active AND NOT prev_sensor_1 THEN
    conveyor_running := TRUE;
    conveyor_speed := 50;
END_IF;

(* Stop conveyor when part reaches sensor 2 *)
IF sensor_2_active AND NOT prev_sensor_2 THEN
    conveyor_running := FALSE;
    conveyor_speed := 0;
END_IF;

(* Update edge detection *)
prev_sensor_1 := sensor_1_active;
prev_sensor_2 := sensor_2_active;
""")

    return program


def generate_motor_safety_program() -> STProgram:
    """
    Generate a motor safety monitoring program.

    Monitors temperature and current, stops motor if limits exceeded.

    Returns:
        STProgram: Motor safety program.
    """
    program = STProgram(name="MotorSafety")

    program.add_variable("TEMP_LIMIT", STDataType.INT, "800", "Temperature limit (80.0C)")
    program.add_variable("CURRENT_LIMIT", STDataType.INT, "100", "Current limit (10.0A)")
    program.add_variable("fault_triggered", STDataType.BOOL, "FALSE", "Local fault flag")

    program.set_body("""
(* E-Stop has highest priority *)
IF e_stop_active THEN
    motor_running := FALSE;
    motor_speed := 0;
    error_code := 5;  (* E-Stop error *)
    fault_alarm := TRUE;
    RETURN;
END_IF;

(* Check temperature limit *)
IF temperature > TEMP_LIMIT THEN
    motor_running := FALSE;
    motor_speed := 0;
    error_code := 2;  (* Temperature high *)
    fault_alarm := TRUE;
    fault_triggered := TRUE;
END_IF;

(* Check current limit *)
IF motor_current > CURRENT_LIMIT THEN
    motor_running := FALSE;
    motor_speed := 0;
    error_code := 3;  (* Overcurrent *)
    fault_alarm := TRUE;
    fault_triggered := TRUE;
END_IF;

(* Clear fault when conditions normalize and motor is stopped *)
IF NOT motor_running AND temperature < TEMP_LIMIT AND motor_current < CURRENT_LIMIT THEN
    IF fault_triggered THEN
        (* Require manual reset - don't auto-clear *)
    END_IF;
END_IF;
""")

    return program


def generate_sorting_station_program() -> STProgram:
    """
    Generate a complete sorting station control program.

    Coordinates motor, conveyor, and sensors for Factory I/O
    sorting station scene.

    Returns:
        STProgram: Complete sorting station program.
    """
    program = STProgram(name="SortingStation")

    program.add_variable("state", STDataType.INT, "0", "State machine: 0=idle, 1=running, 2=sorting, 3=fault")
    program.add_variable("part_count", STDataType.INT, "0", "Parts processed counter")
    program.add_variable("NORMAL_SPEED", STDataType.INT, "60", "Normal conveyor speed")
    program.add_variable("SLOW_SPEED", STDataType.INT, "30", "Slow speed for sorting")

    program.set_body("""
(* Emergency stop handling *)
IF e_stop_active THEN
    state := 3;
    motor_running := FALSE;
    conveyor_running := FALSE;
    motor_speed := 0;
    conveyor_speed := 0;
    fault_alarm := TRUE;
    error_code := 5;
    RETURN;
END_IF;

(* State machine *)
CASE state OF
    0: (* IDLE - waiting for start *)
        IF NOT fault_alarm THEN
            conveyor_running := TRUE;
            conveyor_speed := NORMAL_SPEED;
            motor_running := TRUE;
            motor_speed := 50;
            state := 1;
        END_IF;

    1: (* RUNNING - normal operation *)
        IF sensor_1_active THEN
            (* Part entering - slow down for sorting *)
            conveyor_speed := SLOW_SPEED;
            state := 2;
        END_IF;

    2: (* SORTING - part at sensor 1 *)
        IF sensor_2_active THEN
            (* Part sorted and exiting *)
            part_count := part_count + 1;
            conveyor_speed := NORMAL_SPEED;
            state := 1;
        END_IF;

    3: (* FAULT - stopped *)
        motor_running := FALSE;
        conveyor_running := FALSE;
        (* Require manual reset via clear_error *)
        IF error_code = 0 AND NOT e_stop_active THEN
            fault_alarm := FALSE;
            state := 0;
        END_IF;
END_CASE;

(* Safety monitoring *)
IF temperature > 800 OR motor_current > 100 THEN
    state := 3;
    error_code := 2;  (* Temperature or current fault *)
    fault_alarm := TRUE;
END_IF;
""")

    return program


class STCodeGenerator:
    """
    Utility class for generating ST code from requirements.

    Provides template-based generation and validation for
    common PLC programming patterns.
    """

    @staticmethod
    def create_empty_program(name: str) -> STProgram:
        """Create an empty program template."""
        return STProgram(name=name)

    @staticmethod
    def create_timer_block(
        timer_name: str,
        condition: str,
        duration_ms: int,
        on_complete: str,
    ) -> str:
        """
        Generate timer logic (TON pattern).

        Args:
            timer_name: Name for timer variable
            condition: Boolean condition to start timer
            duration_ms: Timer duration in milliseconds
            on_complete: Action when timer completes

        Returns:
            str: ST code for timer logic
        """
        return f"""
(* Timer: {timer_name} *)
IF {condition} THEN
    {timer_name}_running := TRUE;
    IF {timer_name}_elapsed >= {duration_ms} THEN
        {on_complete}
        {timer_name}_running := FALSE;
        {timer_name}_elapsed := 0;
    ELSE
        {timer_name}_elapsed := {timer_name}_elapsed + 1;  (* Increment each scan *)
    END_IF;
ELSE
    {timer_name}_running := FALSE;
    {timer_name}_elapsed := 0;
END_IF;
"""

    @staticmethod
    def create_interlock(
        output: str,
        enable_conditions: List[str],
        disable_conditions: List[str],
    ) -> str:
        """
        Generate interlock logic.

        Args:
            output: Output variable to control
            enable_conditions: Conditions that must be true to enable
            disable_conditions: Conditions that force disable

        Returns:
            str: ST code for interlock
        """
        enable_expr = " AND ".join(enable_conditions) if enable_conditions else "TRUE"
        disable_expr = " OR ".join(disable_conditions) if disable_conditions else "FALSE"

        return f"""
(* Interlock for {output} *)
IF {disable_expr} THEN
    {output} := FALSE;
ELSIF {enable_expr} THEN
    {output} := TRUE;
END_IF;
"""

    @staticmethod
    def validate_for_micro820(program: STProgram) -> List[str]:
        """
        Validate program for Micro 820 compatibility.

        Args:
            program: STProgram to validate

        Returns:
            List[str]: Compatibility warnings/errors
        """
        warnings = []
        code = program.to_st()

        # Check for unsupported features
        if re.search(r'\bPOINTER\b', code, re.IGNORECASE):
            warnings.append("POINTER type not supported on Micro 820")

        if re.search(r'\bREFERENCE\b', code, re.IGNORECASE):
            warnings.append("REFERENCE type not supported on Micro 820")

        if re.search(r'\bCLASS\b', code, re.IGNORECASE):
            warnings.append("CLASS not supported on Micro 820")

        # Check for proper use of global variables
        for var_name in program.GLOBAL_VARIABLES:
            if var_name in code:
                # Variable is used - check it's not redeclared
                if re.search(rf'\b{var_name}\s*:\s*\w+', code):
                    warnings.append(f"Global variable '{var_name}' should not be redeclared locally")

        return warnings


# Convenience function for quick program generation
def create_program_from_template(template_name: str) -> Optional[STProgram]:
    """
    Create a program from a predefined template.

    Args:
        template_name: One of 'conveyor', 'motor_safety', 'sorting_station'

    Returns:
        STProgram or None if template not found
    """
    templates = {
        "conveyor": generate_conveyor_control,
        "motor_safety": generate_motor_safety_program,
        "sorting_station": generate_sorting_station_program,
    }

    generator = templates.get(template_name.lower())
    if generator:
        return generator()
    return None
